# Released under the MIT License. See LICENSE for details.
#
"""A dummy stub module for the real _babase.

The real _babase is a compiled extension module and only available
in the live engine. This dummy-module allows Pylint/Mypy/etc. to
function reasonably well outside of that environment.

Make sure this file is never included in dirs seen by the engine!

In the future perhaps this can be a stub (.pyi) file, but we will need
to make sure that it works with all our tools (mypy, pylint, pycharm).

NOTE: This file was autogenerated by batools.dummymodule; do not edit by hand.
"""

# I'm sorry Pylint. I know this file saddens you. Be strong.
# pylint: disable=useless-suppression
# pylint: disable=unnecessary-pass
# pylint: disable=use-dict-literal
# pylint: disable=use-list-literal
# pylint: disable=unused-argument
# pylint: disable=missing-docstring
# pylint: disable=too-many-locals
# pylint: disable=redefined-builtin
# pylint: disable=too-many-lines
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=no-value-for-parameter

from __future__ import annotations

from typing import TYPE_CHECKING, overload, Sequence, TypeVar

if TYPE_CHECKING:
    from typing import Any, Callable
    from babase import App
    import babase


_T = TypeVar('_T')

app: App


def _uninferrable() -> Any:
    """Get an "Any" in mypy and "uninferrable" in Pylint."""
    # pylint: disable=undefined-variable
    return _not_a_real_variable  # type: ignore


class AppTimer:
    """Timers are used to run code at later points in time.

    Category: **General Utility Classes**

    This class encapsulates a timer based on app-time.
    The underlying timer will be destroyed when this object is no longer
    referenced. If you do not want to worry about keeping a reference to
    your timer around, use the babase.apptimer() function instead to get a
    one-off timer.

    ##### Arguments
    ###### time
    > Length of time in seconds that the timer will wait before firing.

    ###### call
    > A callable Python object. Remember that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Example

    Use a Timer object to print repeatedly for a few seconds:
    ... def say_it():
    ...     babase.screenmessage('BADGER!')
    ... def stop_saying_it():
    ...     global g_timer
    ...     g_timer = None
    ...     babase.screenmessage('MUSHROOM MUSHROOM!')
    ... # Create our timer; it will run as long as we have the self.t ref.
    ... g_timer = babase.AppTimer(0.3, say_it, repeat=True)
    ... # Now fire off a one-shot timer to kill it.
    ... babase.apptimer(3.89, stop_saying_it)
    """

    def __init__(
        self, time: float, call: Callable[[], Any], repeat: bool = False
    ) -> None:
        pass


class ContextCall:
    """A context-preserving callable.

    Category: **General Utility Classes**

    A ContextCall wraps a callable object along with a reference
    to the current context (see babase.ContextRef); it handles restoring
    the context when run and automatically clears itself if the context
    it belongs to dies.

    Generally you should not need to use this directly; all standard
    Ballistica callbacks involved with timers, materials, UI functions,
    etc. handle this under-the-hood so you don't have to worry about it.
    The only time it may be necessary is if you are implementing your
    own callbacks, such as a worker thread that does some action and then
    runs some game code when done. By wrapping said callback in one of
    these, you can ensure that you will not inadvertently be keeping the
    current activity alive or running code in a torn-down (expired)
    context_ref.

    You can also use babase.WeakCall for similar functionality, but
    ContextCall has the added bonus that it will not run during context_ref
    shutdown, whereas babase.WeakCall simply looks at whether the target
    object instance still exists.

    ##### Examples
    **Example A:** code like this can inadvertently prevent our activity
    (self) from ending until the operation completes, since the bound
    method we're passing (self.dosomething) contains a strong-reference
    to self).
    >>> start_some_long_action(callback_when_done=self.dosomething)

    **Example B:** in this case our activity (self) can still die
    properly; the callback will clear itself when the activity starts
    shutting down, becoming a harmless no-op and releasing the reference
    to our activity.

    >>> start_long_action(
    ...     callback_when_done=babase.ContextCall(self.mycallback))
    """

    def __init__(self, call: Callable) -> None:
        pass

    def __call__(self) -> None:
        """Support for calling."""
        pass


class ContextRef:
    """Store or use a ballistica context.

    Category: **General Utility Classes**

    Many operations such as bascenev1.newnode() or bascenev1.gettexture()
    operate implicitly on a current 'context'. A context is some sort of
    state that functionality can implicitly use. Context determines, for
    example, which scene nodes or textures get added to without having to
    specify it explicitly in the newnode()/gettexture() call. Contexts can
    also affect object lifecycles; for example a babase.ContextCall will
    become a no-op when the context it was created in is destroyed.

    In general, if you are a modder, you should not need to worry about
    contexts; mod code should mostly be getting run in the correct
    context and timers and other callbacks will take care of saving
    and restoring contexts automatically. There may be rare cases,
    however, where you need to deal directly with contexts, and that is
    where this class comes in.

    Creating a babase.ContextRef() will capture a reference to the current
    context. Other modules may provide ways to access their contexts; for
    example a bascenev1.Activity instance has a 'context' attribute. You
    can also use babase.ContextRef.empty() to create a reference to *no*
    context. Some code such as UI calls may expect this and may complain
    if you try to use them within a context.

    ##### Usage
    ContextRefs are generally used with the Python 'with' statement, which
    sets the context they point to as current on entry and resets it to
    the previous value on exit.

    ##### Example
    Explicitly create a few UI bits with no context set.
    (UI stuff may complain if called within a context):
    >>> with bui.ContextRef.empty():
    ...     my_container = bui.containerwidget()
    """

    def __init__(
        self,
    ) -> None:
        pass

    def __enter__(self) -> None:
        """Support for "with" statement."""
        pass

    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
        """Support for "with" statement."""
        pass

    @classmethod
    def empty(cls) -> ContextRef:
        """Return a ContextRef pointing to no context.

        This is useful when code should be run free of a context.
        For example, UI code generally insists on being run this way.
        Otherwise, callbacks set on the UI could inadvertently stop working
        due to a game activity ending, which would be unintuitive behavior.
        """
        return ContextRef()

    def is_empty(self) -> bool:
        """Whether the context was created as empty."""
        return bool()

    def is_expired(self) -> bool:
        """Whether the context has expired."""
        return bool()


class DisplayTimer:
    """Timers are used to run code at later points in time.

    Category: **General Utility Classes**

    This class encapsulates a timer based on display-time.
    The underlying timer will be destroyed when this object is no longer
    referenced. If you do not want to worry about keeping a reference to
    your timer around, use the babase.displaytimer() function instead to get a
    one-off timer.

    Display-time is a time value intended to be used for animation and
    other visual purposes. It will generally increment by a consistent
    amount each frame. It will pass at an overall similar rate to AppTime,
    but trades accuracy for smoothness.

    ##### Arguments
    ###### time
    > Length of time in seconds that the timer will wait before firing.

    ###### call
    > A callable Python object. Remember that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Example

    Use a Timer object to print repeatedly for a few seconds:
    ... def say_it():
    ...     babase.screenmessage('BADGER!')
    ... def stop_saying_it():
    ...     global g_timer
    ...     g_timer = None
    ...     babase.screenmessage('MUSHROOM MUSHROOM!')
    ... # Create our timer; it will run as long as we have the self.t ref.
    ... g_timer = babase.DisplayTimer(0.3, say_it, repeat=True)
    ... # Now fire off a one-shot timer to kill it.
    ... babase.displaytimer(3.89, stop_saying_it)
    """

    def __init__(
        self, time: float, call: Callable[[], Any], repeat: bool = False
    ) -> None:
        pass


class Env:
    """Unchanging values for the current running app instance.
    Access the single shared instance of this class at `babase.app.env`.
    """

    android: bool
    """Is this build targeting an Android based OS?"""

    api_version: int
    """The app's api version.

       Only Python modules and packages associated with the current API
       version number will be detected by the game (see the ba_meta tag).
       This value will change whenever substantial backward-incompatible
       changes are introduced to Ballistica APIs. When that happens,
       modules/packages should be updated accordingly and set to target
       the newer API version number."""

    arcade: bool
    """Whether the app is targeting an arcade-centric experience."""

    build_number: int
    """Integer build number for the engine.

       This value increases by at least 1 with each release of the engine.
       It is independent of the human readable `version` string."""

    config_file_path: str
    """Where the app's config file is stored on disk."""

    data_directory: str
    """Where bundled static app data lives."""

    debug: bool
    """Whether the app is running in debug mode.

       Debug builds generally run substantially slower than non-debug
       builds due to compiler optimizations being disabled and extra
       checks being run."""

    demo: bool
    """Whether the app is targeting a demo experience."""

    device_name: str
    """Human readable name of the device running this app."""

    gui: bool
    """Whether the app is running with a gui.

       This is the opposite of `headless`."""

    headless: bool
    """Whether the app is running headlessly (without a gui).

       This is the opposite of `gui`."""

    python_directory_app: str | None
    """Path where the app expects its bundled modules to live.

       Be aware that this value may be None if Ballistica is running in
       a non-standard environment, and that python-path modifications may
       cause modules to be loaded from other locations."""

    python_directory_app_site: str | None
    """Path where the app expects its bundled pip modules to live.

       Be aware that this value may be None if Ballistica is running in
       a non-standard environment, and that python-path modifications may
       cause modules to be loaded from other locations."""

    python_directory_user: str | None
    """Path where the app expects its user scripts (mods) to live.

       Be aware that this value may be None if Ballistica is running in
       a non-standard environment, and that python-path modifications may
       cause modules to be loaded from other locations."""

    supports_soft_quit: bool
    """Whether the running app supports 'soft' quit options.

       This generally applies to mobile derived OSs, where an act of
       'quitting' may leave the app running in the background waiting
       in case it is used again."""

    test: bool
    """Whether the app is running in test mode.

       Test mode enables extra checks and features that are useful for
       release testing but which do not slow the game down significantly."""

    tv: bool
    """Whether the app is targeting a TV-centric experience."""

    version: str
    """Human-readable version string for the engine; something like '1.3.24'.

       This should not be interpreted as a number; it may contain
       string elements such as 'alpha', 'beta', 'test', etc.
       If a numeric version is needed, use `build_number`."""

    vr: bool
    """Whether the app is currently running in VR."""

    pass


class FeatureSetData:
    """Internal."""

    pass


class SimpleSound:
    """A simple sound wrapper for internal use.

    Do not use for gameplay code as it will only play locally.
    """

    def play(self) -> None:
        """Play the sound locally."""
        return None


class Vec3(Sequence[float]):
    """A vector of 3 floats.

    Category: **General Utility Classes**

    These can be created the following ways (checked in this order):
    - with no args, all values are set to 0
    - with a single numeric arg, all values are set to that value
    - with a single three-member sequence arg, sequence values are copied
    - otherwise assumes individual x/y/z args (positional or keywords)
    """

    x: float
    """The vector's X component."""

    y: float
    """The vector's Y component."""

    z: float
    """The vector's Z component."""

    # pylint: disable=function-redefined

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, value: float):
        pass

    @overload
    def __init__(self, values: Sequence[float]):
        pass

    @overload
    def __init__(self, x: float, y: float, z: float):
        pass

    def __init__(self, *args: Any, **kwds: Any):
        pass

    def __add__(self, other: Vec3) -> Vec3:
        return self

    def __sub__(self, other: Vec3) -> Vec3:
        return self

    @overload
    def __mul__(self, other: float) -> Vec3:
        return self

    @overload
    def __mul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __mul__(self, other: Any) -> Any:
        return self

    @overload
    def __rmul__(self, other: float) -> Vec3:
        return self

    @overload
    def __rmul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __rmul__(self, other: Any) -> Any:
        return self

    # (for index access)
    def __getitem__(self, typeargs: Any) -> Any:
        return 0.0

    def __len__(self) -> int:
        return 3

    # (for iterator access)
    def __iter__(self) -> Any:
        return self

    def __next__(self) -> float:
        return 0.0

    def __neg__(self) -> Vec3:
        return self

    def __setitem__(self, index: int, val: float) -> None:
        pass

    def cross(self, other: Vec3) -> Vec3:
        """Returns the cross product of this vector and another."""
        return Vec3()

    def dot(self, other: Vec3) -> float:
        """Returns the dot product of this vector and another."""
        return float()

    def length(self) -> float:
        """Returns the length of the vector."""
        return float()

    def normalized(self) -> Vec3:
        """Returns a normalized version of the vector."""
        return Vec3()


def add_clean_frame_callback(call: Callable) -> None:
    """(internal)

    Provide an object to be called once the next non-progress-bar-frame has
    been rendered. Useful for queueing things to load in the background
    without elongating any current progress-bar-load.
    """
    return None


def android_get_external_files_dir() -> str:
    """(internal)

    Returns the android external storage path, or None if there is none on
    this device
    """
    return str()


def app_instance_uuid() -> str:
    """(internal)"""
    return str()


def app_is_active() -> bool:
    """(internal)"""
    return bool()


def appname() -> str:
    """(internal)"""
    return str()


def appnameupper() -> str:
    """(internal)

    Return whether this build of the game can display full unicode such as
    Emoji, Asian languages, etc.
    """
    return str()


def apptime() -> babase.AppTime:
    """Return the current app-time in seconds.

    Category: **General Utility Functions**

    App-time is a monotonic time value; it starts at 0.0 when the app
    launches and will never jump by large amounts or go backwards, even if
    the system time changes. Its progression will pause when the app is in
    a suspended state.

    Note that the AppTime returned here is simply float; it just has a
    unique type in the type-checker's eyes to help prevent it from being
    accidentally used with time functionality expecting other time types.
    """
    import babase  # pylint: disable=cyclic-import

    return babase.AppTime(0.0)


def apptimer(time: float, call: Callable[[], Any]) -> None:
    """Schedule a callable object to run based on app-time.

    Category: **General Utility Functions**

    This function creates a one-off timer which cannot be canceled or
    modified once created. If you require the ability to do so, or need
    a repeating timer, use the babase.AppTimer class instead.

    ##### Arguments
    ###### time (float)
    > Length of time in seconds that the timer will wait before firing.

    ###### call (Callable[[], Any])
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as the timer exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ##### Examples
    Print some stuff through time:
    >>> babase.screenmessage('hello from now!')
    >>> babase.apptimer(1.0, babase.Call(babase.screenmessage,
                              'hello from the future!'))
    >>> babase.apptimer(2.0, babase.Call(babase.screenmessage,
    ...                       'hello from the future 2!'))
    """
    return None


def asset_loads_allowed() -> bool:
    """(internal)"""
    return bool()


def audio_shutdown_begin() -> None:
    """(internal)"""
    return None


def audio_shutdown_is_complete() -> bool:
    """(internal)"""
    return bool()


def can_display_full_unicode() -> bool:
    """(internal)"""
    return bool()


def charstr(char_id: babase.SpecialChar) -> str:
    """Get a unicode string representing a special character.

    Category: **General Utility Functions**

    Note that these utilize the private-use block of unicode characters
    (U+E000-U+F8FF) and are specific to the game; exporting or rendering
    them elsewhere will be meaningless.

    See babase.SpecialChar for the list of available characters.
    """
    return str()


def clipboard_get_text() -> str:
    """Return text currently on the system clipboard.

    Category: **General Utility Functions**

    Ensure that babase.clipboard_has_text() returns True before calling
     this function.
    """
    return str()


def clipboard_has_text() -> bool:
    """Return whether there is currently text on the clipboard.

    Category: **General Utility Functions**

    This will return False if no system clipboard is available; no need
     to call babase.clipboard_is_supported() separately.
    """
    return bool()


def clipboard_is_supported() -> bool:
    """Return whether this platform supports clipboard operations at all.

    Category: **General Utility Functions**

    If this returns False, UIs should not show 'copy to clipboard'
    buttons, etc.
    """
    return bool()


def clipboard_set_text(value: str) -> None:
    """Copy a string to the system clipboard.

    Category: **General Utility Functions**

    Ensure that babase.clipboard_is_supported() returns True before adding
     buttons/etc. that make use of this functionality.
    """
    return None


def commit_config(config: str) -> None:
    """(internal)"""
    return None


def complete_shutdown() -> None:
    """Complete the shutdown process, triggering the app to exit."""
    return None


def contains_python_dist() -> bool:
    """(internal)"""
    return bool()


def debug_print_py_err() -> None:
    """(internal)

    Debugging func for tracking leaked Python errors in the C++ layer.
    """
    return None


def dev_console_add_button(
    label: str,
    x: float,
    y: float,
    width: float,
    height: float,
    call: Callable[[], Any] | None,
    h_anchor: str,
    label_scale: float,
    corner_radius: float,
    style: str,
) -> None:
    """(internal)"""
    return None


def dev_console_add_python_terminal() -> None:
    """(internal)"""
    return None


def dev_console_add_text(
    text: str,
    x: float,
    y: float,
    h_anchor: str,
    h_align: str,
    v_align: str,
    scale: float,
) -> None:
    """(internal)"""
    return None


def dev_console_base_scale() -> float:
    """(internal)"""
    return float()


def dev_console_input_adapter_finish() -> None:
    """(internal)"""
    return None


def dev_console_request_refresh() -> None:
    """(internal)"""
    return None


def dev_console_tab_height() -> float:
    """(internal)"""
    return float()


def dev_console_tab_width() -> float:
    """(internal)"""
    return float()


def displaytime() -> babase.DisplayTime:
    """Return the current display-time in seconds.

    Category: **General Utility Functions**

    Display-time is a time value intended to be used for animation and other
    visual purposes. It will generally increment by a consistent amount each
    frame. It will pass at an overall similar rate to AppTime, but trades
    accuracy for smoothness.

    Note that the value returned here is simply a float; it just has a
    unique type in the type-checker's eyes to help prevent it from being
    accidentally used with time functionality expecting other time types.
    """
    import babase  # pylint: disable=cyclic-import

    return babase.DisplayTime(0.0)


def displaytimer(time: float, call: Callable[[], Any]) -> None:
    """Schedule a callable object to run based on display-time.

    Category: **General Utility Functions**

    This function creates a one-off timer which cannot be canceled or
    modified once created. If you require the ability to do so, or need
    a repeating timer, use the babase.DisplayTimer class instead.

    Display-time is a time value intended to be used for animation and other
    visual purposes. It will generally increment by a consistent amount each
    frame. It will pass at an overall similar rate to AppTime, but trades
    accuracy for smoothness.

    ##### Arguments
    ###### time (float)
    > Length of time in seconds that the timer will wait before firing.

    ###### call (Callable[[], Any])
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as the timer exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ##### Examples
    Print some stuff through time:
    >>> babase.screenmessage('hello from now!')
    >>> babase.displaytimer(1.0, babase.Call(babase.screenmessage,
    ...                       'hello from the future!'))
    >>> babase.displaytimer(2.0, babase.Call(babase.screenmessage,
    ...                       'hello from the future 2!'))
    """
    return None


def do_apply_app_config() -> None:
    """(internal)"""
    return None


def do_once() -> bool:
    """Return whether this is the first time running a line of code.

    Category: **General Utility Functions**

    This is used by 'print_once()' type calls to keep from overflowing
    logs. The call functions by registering the filename and line where
    The call is made from.  Returns True if this location has not been
    registered already, and False if it has.

    ##### Example
    This print will only fire for the first loop iteration:
    >>> for i in range(10):
    ... if babase.do_once():
    ...     print('HelloWorld once from loop!')
    """
    return bool()


def ehv() -> None:
    """(internal)"""
    return None


def emit_log(name: str, level: str, message: str) -> None:
    """(internal)

    Sends a log message to the in-app console and any per-platform
    log destinations (Android log, etc.). This generally is not called
    directly and should instead be fed Python logging output.
    """
    return None


def empty_app_mode_handle_intent_default() -> None:
    """(internal)"""
    return None


def empty_app_mode_handle_intent_exec(command: str) -> None:
    """(internal)"""
    return None


def env() -> dict:
    """(internal)

    Returns a dict containing general info about the operating environment
    such as version, platform, etc.
    This info is now exposed through babase.App; refer to those docs for
    info on specific elements.
    """
    return dict()


def evaluate_lstr(value: str) -> str:
    """(internal)"""
    return str()


def exec_arg() -> str | None:
    """(internal)"""
    return ''


def fade_screen(
    to: int = 0, time: float = 0.25, endcall: Callable[[], None] | None = None
) -> None:
    """(internal)

    Fade the local game screen in our out from black over a duration of
    time. if "to" is 0, the screen will fade out to black.  Otherwise it
    will fade in from black. If endcall is provided, it will be run after a
    completely faded frame is drawn.
    """
    return None


def fatal_error(message: str) -> None:
    """Trigger a fatal error. Use this in situations where it is not possible
    for the engine to continue on in a useful way. This can sometimes
    help provide more clear information at the exact source of a problem
    as compared to raising an Exception. In the vast majority of cases,
    however, Exceptions should be preferred.
    """
    return None


def fullscreen_control_available() -> bool:
    """(internal)"""
    return bool()


def fullscreen_control_get() -> bool:
    """(internal)"""
    return bool()


def fullscreen_control_key_shortcut() -> str | None:
    """(internal)"""
    return ''


def fullscreen_control_set(val: bool) -> None:
    """(internal)"""
    return None


def get_appconfig_builtin_keys() -> list[str]:
    """(internal)"""
    return ['blah', 'blah2']


def get_appconfig_default_value(key: str) -> Any:
    """(internal)"""
    return _uninferrable()


def get_camera_position() -> tuple[float, ...]:
    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return (0.0, 0.0, 0.0)


def get_camera_target() -> tuple[float, ...]:
    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return (0.0, 0.0, 0.0)


def get_dev_console_input_text() -> str:
    """(internal)"""
    return str()


def get_display_resolution() -> tuple[int, int] | None:
    """(internal)

    Return the currently selected display resolution for fullscreen
    display. Returns None if resolutions cannot be directly set.
    """
    return (0, 0)


def get_idle_time() -> int:
    """(internal)

    Returns the amount of time since any game input has been received.
    """
    return int()


def get_immediate_return_code() -> int | None:
    """(internal)"""
    return 0


def get_low_level_config_value(key: str, default_value: int) -> int:
    """(internal)"""
    return int()


def get_max_graphics_quality() -> str:
    """(internal)

    Return the max graphics-quality supported on the current hardware.
    """
    return str()


def get_replays_dir() -> str:
    """(internal)"""
    return str()


def get_string_height(string: str, suppress_warning: bool = False) -> float:
    """(internal)

    Given a string, returns its height using the standard small app
    font.
    """
    return float()


def get_string_width(string: str, suppress_warning: bool = False) -> float:
    """(internal)

    Given a string, returns its width using the standard small app
    font.
    """
    return float()


def get_thread_name() -> str:
    """(internal)

    Returns the name of the current thread.
    This may vary depending on platform and should not be used in logic;
    only for debugging.
    """
    return str()


def get_v1_cloud_log() -> str:
    """(internal)"""
    return str()


def get_v1_cloud_log_file_path() -> str:
    """(internal)

    Return the path to the app log file.
    """
    return str()


def get_volatile_data_directory() -> str:
    """(internal)

    Return the path to the app volatile data directory.
    This directory is for data generated by the app that does not
    need to be backed up and can be recreated if necessary.
    """
    return str()


def getapp() -> babase.App:
    """(internal)"""
    import babase  # pylint: disable=cyclic-import

    return babase.App()


def getsimplesound(name: str) -> SimpleSound:
    """(internal)."""
    return SimpleSound()


def graphics_shutdown_begin() -> None:
    """(internal)"""
    return None


def graphics_shutdown_is_complete() -> bool:
    """(internal)"""
    return bool()


def has_user_run_commands() -> bool:
    """(internal)"""
    return bool()


def hastouchscreen() -> bool:
    """(internal)

    Return whether a touchscreen is present on the current device.
    """
    return bool()


def have_chars(text: str) -> bool:
    """(internal)"""
    return bool()


def have_permission(permission: babase.Permission) -> bool:
    """(internal)"""
    return bool()


def in_logic_thread() -> bool:
    """(internal)

    Returns whether or not the current thread is the logic thread.
    """
    return bool()


def increment_analytics_count(name: str, increment: int = 1) -> None:
    """(internal)"""
    return None


def increment_analytics_count_raw_2(
    name: str, uses_increment: bool = True, increment: int = 1
) -> None:
    """(internal)"""
    return None


def increment_analytics_counts_raw(name: str, increment: int = 1) -> None:
    """(internal)"""
    return None


def is_log_full() -> bool:
    """(internal)"""
    return bool()


def is_os_playing_music() -> bool:
    """(internal)

    Tells whether the OS is currently playing music of some sort.

    (Used to determine whether the app should avoid playing its own)
    """
    return bool()


def is_xcode_build() -> bool:
    """(internal)"""
    return bool()


def lifecyclelog(message: str) -> None:
    """(internal)"""
    return None


def lock_all_input() -> None:
    """(internal)

    Prevents all keyboard, mouse, and gamepad events from being processed.
    """
    return None


def login_adapter_back_end_active_change(login_type: str, active: bool) -> None:
    """(internal)"""
    return None


def login_adapter_get_sign_in_token(login_type: str, attempt_id: int) -> None:
    """(internal)"""
    return None


def mac_music_app_get_playlists() -> list[str]:
    """(internal)"""
    return ['blah', 'blah2']


def mac_music_app_get_volume() -> int:
    """(internal)"""
    return int()


def mac_music_app_init() -> None:
    """(internal)"""
    return None


def mac_music_app_play_playlist(playlist: str) -> bool:
    """(internal)"""
    return bool()


def mac_music_app_set_volume(volume: int) -> None:
    """(internal)"""
    return None


def mac_music_app_stop() -> None:
    """(internal)"""
    return None


def mark_log_sent() -> None:
    """(internal)"""
    return None


def music_player_play(files: Any) -> None:
    """(internal)

    Starts internal music file playback (for internal use)
    """
    return None


def music_player_set_volume(volume: float) -> None:
    """(internal)

    Sets internal music player volume (for internal use)
    """
    return None


def music_player_shutdown() -> None:
    """(internal)

    Finalizes internal music file playback (for internal use)
    """
    return None


def music_player_stop() -> None:
    """(internal)

    Stops internal music file playback (for internal use)
    """
    return None


def native_review_request() -> None:
    """(internal)"""
    return None


def native_review_request_supported() -> bool:
    """(internal)"""
    return bool()


def native_stack_trace() -> str | None:
    """Return a native stack trace as a string, or None if not available.

    Category: **General Utility Functions**

    Stack traces contain different data and formatting across platforms.
    Only use them for debugging.
    """
    return ''


def on_app_running() -> None:
    """(internal)"""
    return None


def on_empty_app_mode_activate() -> None:
    """(internal)"""
    return None


def on_empty_app_mode_deactivate() -> None:
    """(internal)"""
    return None


def on_initial_app_mode_set() -> None:
    """(internal)"""
    return None


def open_dir_externally(path: str) -> None:
    """(internal)

    Open the provided dir in the default external app.
    """
    return None


def open_file_externally(path: str) -> None:
    """(internal)

    Open the provided file in the default external app.
    """
    return None


def pre_env() -> dict:
    """(internal)

    Returns a dict containing general info about the operating environment
    such as version, platform, etc.
    This info is now exposed through babase.App; refer to those docs for
    info on specific elements.
    """
    return dict()


def print_context() -> None:
    """(internal)

    Prints info about the current context_ref state; for debugging.
    """
    return None


def print_load_info() -> None:
    """(internal)

    Category: **General Utility Functions**
    """
    return None


def pushcall(
    call: Callable,
    from_other_thread: bool = False,
    suppress_other_thread_warning: bool = False,
    other_thread_use_fg_context: bool = False,
    raw: bool = False,
) -> None:
    """Push a call to the logic event-loop.
    Category: **General Utility Functions**

    This call expects to be used in the logic thread, and will automatically
    save and restore the babase.Context to behave seamlessly.

    If you want to push a call from outside of the logic thread,
    however, you can pass 'from_other_thread' as True. In this case
    the call will always run in the UI context_ref on the logic thread
    or whichever context_ref is in the foreground if
    other_thread_use_fg_context is True.
    Passing raw=True will disable thread checks and context_ref sets/restores.
    """
    return None


# noinspection PyShadowingBuiltins
def quit(
    confirm: bool = False, quit_type: babase.QuitType | None = None
) -> None:
    """Quit the app.

    Category: **General Utility Functions**

    If 'confirm' is True, a confirm dialog will be presented if conditions
    allow; otherwise the quit will still be immediate.
    See docs for babase.QuitType for explanations of the optional
    'quit_type' arg.
    """
    return None


def reached_end_of_babase() -> None:
    """A simple user-agent-string that should be used in any web requests made
    on behalf of the engine.
    """
    return None


def reload_media() -> None:
    """(internal)

    Reload all currently loaded game media; useful for
    development/debugging.
    """
    return None


def request_permission(permission: babase.Permission) -> None:
    """(internal)"""
    return None


def resolve_appconfig_value(key: str) -> Any:
    """(internal)"""
    return _uninferrable()


def run_app() -> None:
    """Run the app to completion.

    Note that this only works on platforms/builds where ballistica
    manages its own event loop.
    """
    return None


def safecolor(
    color: Sequence[float], target_intensity: float = 0.6
) -> tuple[float, ...]:
    """Given a color tuple, return a color safe to display as text.

    Category: **General Utility Functions**

    Accepts tuples of length 3 or 4. This will slightly brighten very
    dark colors, etc.
    """
    return (0.0, 0.0, 0.0)


def screenmessage(
    message: str | babase.Lstr,
    color: Sequence[float] | None = None,
    log: bool = False,
) -> None:
    """Print a message to the local client's screen, in a given color.

    Category: **General Utility Functions**

    Note that this version of the function is purely for local display.
    To broadcast screen messages in network play, look for methods such as
    broadcastmessage() provided by the scene-version packages.
    """
    return None


def set_analytics_screen(screen: str) -> None:
    """Used for analytics to see where in the app players spend their time.

    Category: **General Utility Functions**

    Generally called when opening a new window or entering some UI.
    'screen' should be a string description of an app location
    ('Main Menu', etc.)
    """
    return None


def set_camera_manual(value: bool) -> None:
    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_camera_position(x: float, y: float, z: float) -> None:
    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_camera_target(x: float, y: float, z: float) -> None:
    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_dev_console_input_text(val: str) -> None:
    """(internal)"""
    return None


def set_internal_language_keys(
    listobj: list[tuple[str, str]], random_names_list: list[tuple[str, str]]
) -> None:
    """(internal)"""
    return None


def set_low_level_config_value(key: str, value: int) -> None:
    """(internal)"""
    return None


def set_platform_misc_read_vals(mode: str) -> None:
    """(internal)"""
    return None


def set_thread_name(name: str) -> None:
    """(internal)

    Sets the name of the current thread (on platforms where this is
    available). EventLoop names are only for debugging and should
    not be used in logic, as naming behavior can vary across platforms.
    """
    return None


def set_ui_input_device(input_device_id: int | None) -> None:
    """(internal)

    Sets the input-device that currently owns the user interface.
    """
    return None


def setup_sigint() -> None:
    """(internal)"""
    return None


def show_progress_bar() -> None:
    """(internal)

    Category: **General Utility Functions**
    """
    return None


def shutdown_suppress_begin() -> bool:
    """(internal)"""
    return bool()


def shutdown_suppress_count() -> int:
    """(internal)"""
    return int()


def shutdown_suppress_end() -> None:
    """(internal)"""
    return None


def submit_analytics_counts() -> None:
    """(internal)"""
    return None


def supports_max_fps() -> bool:
    """(internal)"""
    return bool()


def supports_open_dir_externally() -> bool:
    """(internal)

    Return whether the current app/platform supports opening dirs externally
    (in the Mac Finder, Windows Explorer, etc.).
    """
    return bool()


def supports_vsync() -> bool:
    """(internal)"""
    return bool()


def temp_testing() -> bool:
    """(internal)"""
    return bool()


def unlock_all_input() -> None:
    """(internal)

    Resumes normal keyboard, mouse, and gamepad event processing.
    """
    return None


def user_agent_string() -> str:
    """(internal)"""
    return str()


def user_ran_commands() -> None:
    """(internal)"""
    return None


def using_game_center() -> bool:
    """(internal)"""
    return bool()


def using_google_play_game_services() -> bool:
    """(internal)"""
    return bool()


def v1_cloud_log(message: str) -> None:
    """(internal)

    Push messages to the old v1 cloud log.
    """
    return None


def workspaces_in_use() -> bool:
    """(internal)

    Returns whether workspaces functionality has been enabled at
    any point this run.
    """
    return bool()
